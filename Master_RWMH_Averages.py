'''
Implementation of standard random walk Metropolis-Hastings Algorithm for the double-glazing inverse problem. This version averages the heat in the domain
instead of interpolating onto a mesh.
'''

from fenics import *
import numpy as np
from vedo.dolfin import plot, Latex, clear, histogram
import matplotlib.pyplot as plt

from Master_Solver import master_solver
from Stretch_Mesh import stretch_mesh
from Time_Stepping import time_organiser

def log_ratio(#y,
              #u1,
              #u2,
              alpha1,
              alpha2,
              sigma_p,
              sigma_l,
              mu_p,
              f1_norm,
              f2_norm
              ):
    '''
    Calculate the log acceptance ratio between mesh point values using L2 norm.

    Inputs:
        alpha1:         Float:      First alpha value for comparison.
        alpha2:         Float:      Second alpha value for comaprison.
        sigma_p:        Float:      Variance of Gaussian prior density.
        sigma_l:        Float:      Variance used in likelihood function.
        mu_p:           Float:      Mean of Gaussian prior density.
        f1_norm:        Float:      L2 norm between data and solution generated with alpha1.
        f2_norm:        Float:      L2 norm between data and solution generated with alpha2.
    Outputs:
        log_ratio:      Float:      Natural log of ratio of likelihoods, used in acceptance.
    '''
    log_ratio = 0.5 * ((((alpha1 - mu_p) ** 2 - (alpha2 - mu_p) ** 2) / sigma_p ** 2) + (f1_norm ** 2 - f2_norm ** 2)/ sigma_l ** 2)
    
    return log_ratio

def A_mat(u):
    '''
    Format u.
    '''
    return u

def random_walk_metropolis(alpha0,
                           y, 
                           sigma_q, 
                           sigma_p,
                           sigma_l,
                           mu_p,
                           nx,
                           ny,
                           tau,
                           epsilon,
                           iterations,
                           burnin,
                           num_steps,
                           dt_min,
                           dt_max,
                           reg
                           ):
    '''
    Carries out iterations of the random walk Metropolis-Hastings Algorithm using likelihood estimator.

    Inputs:
        alpha0:         Float:      Initial value for alpha.
        y:              np.Array:   Generated data encoding information about heat distribution in time. Averaged in space!
        sigma_q:        Float:      Variance of proposal distribution (stepsize).
        sigma_p:        Float:      Variance of prior distribution. 
        sigma_l:        Float:      Variance used in likelihood caluclation (hyperparameter).
        mu_p:           Float:      Mean of prior distribution.
        nx:             Int:        Size of fine mesh (must be square, nx=ny).
        tau:            Float:      Rate of growth of hot wall boundary.
        epsilon:        Float:      Diffusion coefficient from advection-diffusion equation.
        iterations:     Int:        Desired number of iterations for delayed acceptance alogorithm.
        burnin:         Int:        Desired number of burn-in iterations.
        num_steps:      Int:        Number of steps in time calculated by the double-glazing solver.
        dt_min:         Float:      Initial timestepping value (variable time-stepping).
        dt_max:         Float:      Limit of dt (variable time-stepping)
        reg:            Float:      Regularisation constant used in variable time-stepping (hyperparameter)
    Outputs:
        alpha_list:     List:       List of samples for alpha generated by delayed acceptance algorithm.
    '''

    mesh = stretch_mesh(nx=nx, ny=ny)
    
    alpha_list = [alpha0]
    alpha1 = alpha0
    A_list = []

    u1, __ = master_solver(mesh,
                           tau,
                           alpha1,
                           epsilon,
                           num_steps,
                           dt_min,
                           dt_max,
                           reg
                           )

    # Take average in space.
    u1 = np.mean(u1, axis=1)

    u1_norm = np.linalg.norm(y-A_mat(u1))

    # Initialise accept-reject ratio list:
    accept = 0
    reject = 0
    ratio_list = []

    for i in range(iterations):

        alpha2 = np.random.normal(alpha1, sigma_q)
        u2, __ = master_solver(mesh,
                               tau,
                               alpha2,
                               epsilon,
                               num_steps,
                               dt_min,
                               dt_max,
                               reg
                               )

        # Take average in space.
        u2 = np.mean(u2, axis=1)

        u2_norm = np.linalg.norm(y-A_mat(u2))

        A = log_ratio(#y,
                      #u1,
                      #u2,
                      alpha1,
                      alpha2,
                      sigma_p,
                      sigma_l,
                      mu_p,
                      u1_norm,
                      u2_norm
                      )

        A_list.append(A.copy())

        if A >= 0 or np.log(np.random.uniform(0,1)) <= A:
            alpha1 = alpha2
            u1 = u2
            u1_norm = u2_norm
            accept += 1
        else:
            reject += 1
        
        # Once burn-in iterations are complete...
        if i >= burnin:

            # ...add sample to list.
            alpha_list.append(alpha1)

            # Add ratio to accept-reject ratio list.
            if reject == 0 and accept != 0:
                ratio_list.append(1)
            else:
                ratio_list.append(accept/reject)
        
        print(i)

    return alpha_list, A_list, ratio_list


if __name__ == "__main__":

    import pickle 

    def main():

        # Solver parameters.
        alpha0 = 2                              # Initial guess for alpha.
        tau = 1/10                              # Rate of growth of hot wall.
        epsilon = 1/100                         # Diffusion coefficient.
        num_steps = 60                          # Number of steps to run solver for.
        nx = 32                                 # Number of horizontal grid points on mesh (ny = nx).
        ny = 32                                 # Number of vertical grid points on mesh. 
        
        # Variable time-stepping variables.                                                                                                          
        dt_min = 1e-3                           # Inital value for dt.
        dt_max = 0.1                            # Limit of dt values as t appraches infty.
        reg = 10                                # Regularisation constant.

        # RWMH parameters.
        iterations = 2000                       # Number of samples to generate (-burnin).
        burnin = 0                              # Number of burn-in iterations.
        sigma_q = 0.5                           # Vairance of normal proposal distribution.
        sigma_p = 1                             # Variance of normal prior.
        mu_p = 0                                # Mean of normal prior.
        sigma_l = 0.2                           # Variance in likelihood (estimate of noise in data):

        # Data augmentation.
        # alpha_star = 0                        # True value for alpha.                          
        var_noise = 0.2                         # Variance of noise added to data (sigma_l should approxiamte this).


        with open('Master/Data_eps100_num150000_tau10_alpha0/master_data_32_interpolate', 'rb') as file:
            y_star = pickle.load(file)
        
        y_star_coarse = time_organiser(y_star,
                                       dt_min,
                                       dt_max,
                                       tau,
                                       reg,
                                       num_steps
                                       )[:-1] # Make removing last element more elegant!
        
        # Take mean in space.
        y_star_coarse_av = np.mean(y_star_coarse, axis=1)

        # Add normally distributed noise.
        y = y_star_coarse_av + np.random.normal(0, var_noise, np.shape(y_star_coarse_av))

        #+ np.random.normal(np.zeros(np.shape(y_star)), var_noise)

        alpha_list, A_list, ratio_list = random_walk_metropolis(alpha0,
                                                                y, 
                                                                sigma_q, 
                                                                sigma_p,
                                                                sigma_l,
                                                                mu_p,
                                                                nx,
                                                                ny,
                                                                tau,
                                                                epsilon,
                                                                iterations,
                                                                burnin,
                                                                num_steps,
                                                                dt_min,
                                                                dt_max,
                                                                reg
                                                                )

        return alpha_list, y, A_list, ratio_list
    
    alpha_list, y, A_list, ratio_list = main()

    print(alpha_list)
    print(ratio_list)

    # with open(f'Master/RWMH_Sampling_Data/5100iter_0burnin_sq01_sp1_mp0_sl02_noise02_nx32_tau01_eps001_numsteps60-150000_AVERAGE_SAMPLE', 'wb') as file:
    #     pickle.dump(alpha_list, file)
    # with open(f'Master/RWMH_Sampling_Data/5100iter_0burnin_sq01_sp1_mp0_sl02_noise02_nx32_tau01_eps001_numsteps60-150000_AVERAGE_DATA', 'wb') as file:
    #     pickle.dump(y, file)
