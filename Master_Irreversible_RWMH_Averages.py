'''
Implementation of the Irreversible Random Walk Metropolis Hastings sampling algorithm for the double-glazing inverse problem. Referece paper: 
"Irreversible Samplers from Jump and Continuous Markov Processes" by Yi-An Ma, Emily B. Fox, Tianqi Chen and Lei Wu.
'''

from fenics import *
import numpy as np
from vedo.dolfin import plot, Latex, clear, histogram
import matplotlib.pyplot as plt

from Master_Solver import master_solver
from Stretch_Mesh import stretch_mesh
from Time_Stepping import time_organiser

def log_ratio(#y,
              #u1,
              #u2,
              alpha1,
              alpha2,
              sigma_p,
              sigma_l,
              mu_p,
              f1_norm,
              f2_norm
              ):
    '''
    Calculate the log acceptance ratio between mesh point values using L2 norm.

    Inputs:
        alpha1:         Float:      First alpha value for comparison.
        alpha2:         Float:      Second alpha value for comaprison.
        sigma_p:        Float:      Variance of Gaussian prior density.
        sigma_l:        Float:      Variance used in likelihood function.
        mu_p:           Float:      Mean of Gaussian prior density.
        f1_norm:        Float:      L2 norm between data and solution generated with alpha1.
        f2_norm:        Float:      L2 norm between data and solution generated with alpha2.
    Outputs:
        log_ratio:      Float:      Natural log of ratio of likelihoods, used in acceptance.
    '''

    log_ratio = 0.5 * ((((alpha1 - mu_p) ** 2 - (alpha2 - mu_p) ** 2) / sigma_p ** 2) + (f1_norm ** 2 - f2_norm ** 2)/ sigma_l ** 2)

    return log_ratio

def A_mat(u):
    '''
    Format u.
    '''
    return u

def irreversible_walk_metropolis(alpha0,
                                 y, 
                                 k,
                                 theta, 
                                 sigma_p,
                                 sigma_l,
                                 mu_p,
                                 nx,
                                 ny,
                                 tau,
                                 epsilon,
                                 iterations,
                                 burnin,
                                 num_steps,
                                 dt_min,
                                 dt_max,
                                 reg
                                 ):
    '''
    Carries out iterations of the random walk Metropolis-Hastings Algorithm using likelihood estimator.

    Inputs:
        alpha0:         Float:      Initial value for alpha.
        y:              np.Array:   Generated data encoding information about heat distribution in time.
        k:              Float:      Gamma distribution parameter (shape) used in proposal distributions (equivalent to alpha).
        theta:          Float:      Gamma distribution parameter (scale) used in proposal distributions (equivalent to 1/beta).
        sigma_p:        Float:      Variance of prior distribution. 
        sigma_l:        Float:      Variance used in likelihood caluclation (hyperparameter).
        mu_p:           Float:      Mean of prior distribution.
        nx:             Int:        Size of fine mesh (must be square, nx=ny).
        tau:            Float:      Rate of growth of hot wall boundary.
        epsilon:        Float:      Diffusion coefficient from advection-diffusion equation.
        iterations:     Int:        Desired number of iterations for delayed acceptance alogorithm.
        burnin:         Int:        Desired number of burn-in iterations.
        num_steps:      Int:        Number of steps in time calculated by the double-glazing solver.
        dt_min:         Float:      Initial timestepping value (variable time-stepping).
        dt_max:         Float:      Limit of dt (variable time-stepping)
        reg:            Float:      Regularisation constant used in variable time-stepping (hyperparameter)
    Outputs:
        alpha_list:     List:       List of samples for alpha generated by delayed acceptance algorithm.
    '''
    
    # Generate FEniCS mesh using Stretch_Mesh.py.
    mesh = stretch_mesh(nx=nx, ny=ny)

    # Initialise alpha sample and sample list.    
    alpha_list = [alpha0]
    alpha1 = alpha0

    # Initialise log acceptance ratio list.
    A_list = []

    # Generate numerical solution of double-glazing problem for inital alpha.
    u1, __ = master_solver(mesh,
                           tau,
                           alpha1,
                           epsilon,
                           num_steps,
                           dt_min,
                           dt_max,
                           reg
                           )

    # Take mean in space.
    u1 = np.mean(u1, axis=1)

    # Caluclate norm between generated solution and the data.
    u1_norm = np.linalg.norm(y-A_mat(u1))

    # Irreversible walk setup.
    z_p = np.random.choice([-1,1])
    accepted = True

    # Initialise accept-reject ratio list:
    accept = 0
    reject = 0
    ratio_list = []

    # Begin iterations.
    for i in range(iterations):
        
        # If rejected, change parameter z_p, i.e. change direction of walk.
        if accepted == False:
            z_p = -1 * z_p
        print(z_p)
        
        # Propose next sample for alpha.
        alpha2 = alpha1 + z_p * np.random.gamma(k, theta)

        # Generate numerical solution of double-glazing problem for alpha2.
        u2, __ = master_solver(mesh,
                               tau,
                               alpha2,
                               epsilon,
                               num_steps,
                               dt_min,
                               dt_max,
                               reg
                               )
        
        # Take mean in space.
        u2 = np.mean(u2, axis=1)

        # Caluclate norm between generated solution and the data.
        u2_norm = np.linalg.norm(y-A_mat(u2))

        # Calculate acceptance ratio for proposed alpha.
        A = log_ratio(#y,
                      #u1,                      
                      #u2,
                      alpha1,
                      alpha2,
                      sigma_p,
                      sigma_l,
                      mu_p,
                      u1_norm,
                      u2_norm
                      )
        
        A_list.append(A.copy())

        # M-H Acceptance step.
        if A >= 0 or np.log(np.random.uniform(0,1)) <= A:

            # Take proposal as next sample.
            alpha1 = alpha2

            # Reassign variables accordingly.
            u1 = u2
            u1_norm = u2_norm
            accepted = True         # i.e. keep z_p the same for next iteration.
            accept += 1
        else:
            accepted = False        # i.e. change z_p next iteration.
            reject += 1

        # Once burn-in iterations are complete...
        if i >= burnin:

            # ...add sample to list.
            alpha_list.append(alpha1)

            # Add ratio to accept-reject ratio list.
            if reject == 0 and accept != 0:
                ratio_list.append(1)
            else:
                ratio_list.append(accept/reject)
            
        print(i)

    return alpha_list, A_list, ratio_list


if __name__ == "__main__":

    import pickle 

    def main():

        # Solver parameters.
        alpha0 = 2                              # Initial guess for alpha.
        tau = 1/10                              # Rate of growth of hot wall.
        epsilon = 1/100                         # Diffusion coefficient.
        num_steps = 60                          # Number of steps to run solver for.
        nx = 32                                 # Number of horizontal grid points on mesh (ny = nx).
        ny = 32                                 # Number of vertical grid points on mesh. 
        
        # Variable time-stepping variables.                                                                                                          
        dt_min = 1e-3                           # Inital value for dt.
        dt_max = 0.1                            # Limit of dt values as t appraches infty.
        reg = 10                                # Regularisation constant.

        # Metropolis-Hastings parameters.
        iterations = 500                        # Number of samples to generate (-burnin).
        burnin = 0                              # Number of burnin iterations.
        sigma_p = 1                             # Variance of normal prior.
        mu_p = 0                                # Mean of normal prior.
        sigma_l = 0.2                           # Variance in likelihood (estimate of noise in data):

        # Irreversible RWMH varibles.
        alpha = 1/np.pi                         # alpha parameter used in gamma proposal (different to wind-speed variable).
        beta = np.sqrt(2/np.pi)                 # beta parameter used in gamma proposal.

        # Changing form of irreversilbe variables for use in in-built functions.
        k = alpha                               # 'Shape' parameter for gamma distribution (=alpha).
        theta = 1/beta                          # 'Scale' paramter for gamma distribution (=1/beta).

        # Data augmentation.
        # alpha_star = 0                        # True value for alpha.                          
        var_noise = 0.2                         # Variance of noise added to data (sigma_l should approxiamte this).

        # Open high resolution data file.
        with open('Master/Data_eps100_num150000_tau10_alpha0/master_data_32_interpolate', 'rb') as file:
            y_star = pickle.load(file)
        
        # Thin high resolution data to correspond with variable time-stepping.
        y_star_coarse = time_organiser(y_star,
                                       dt_min,
                                       dt_max,
                                       tau,
                                       reg,
                                       num_steps
                                       )[:-1] # Make removing last element more elegant!

        
        # Take mean in space.
        y_star_coarse_av = np.mean(y_star_coarse, axis=1)

        # Add normally distributed noise.
        y = y_star_coarse_av + np.random.normal(0, var_noise, np.shape(y_star_coarse_av))

        # Run Irreversible RWMH algorithm.
        alpha_list, A_list, ratio_list = irreversible_walk_metropolis(alpha0,
                                                                      y, 
                                                                      k,
                                                                      theta, 
                                                                      sigma_p,
                                                                      sigma_l,
                                                                      mu_p,
                                                                      nx,
                                                                      ny,
                                                                      tau,
                                                                      epsilon,
                                                                      iterations,
                                                                      burnin,
                                                                      num_steps,
                                                                      dt_min,
                                                                      dt_max,
                                                                      reg
                                                                      )

        return alpha_list, A_list, ratio_list
    
    alpha_list, A_list, ratio_list = main()

    print(alpha_list)
    print(ratio_list)