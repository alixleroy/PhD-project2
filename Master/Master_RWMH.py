'''
Implementation of standard random walk Metropolis-Hastings Algorithm for the double-glazing inverse problem.
'''

from fenics import *
import numpy as np
from vedo.dolfin import plot, Latex, clear, histogram
import matplotlib.pyplot as plt

from Master_Solver import master_solver
from Stretch_Mesh import stretch_mesh
from Time_Stepping import time_organiser

def log_ratio(#y,
              #u1,
              #u2,
              alpha1,
              alpha2,
              sigma_p,
              sigma_l,
              mu_p,
              f1_norm,
              f2_norm
              ):
    '''
    Calculate the log acceptance ratio between mesh point values using L2 norm.

    Inputs:
        alpha1:         Float:      First alpha value for comparison.
        alpha2:         Float:      Second alpha value for comaprison.
        sigma_p:        Float:      Variance of Gaussian prior density.
        sigma_l:        Float:      Variance used in likelihood function.
        mu_p:           Float:      Mean of Gaussian prior density.
        f1_norm:        Float:      L2 norm between data and solution generated with alpha1.
        f2_norm:        Float:      L2 norm between data and solution generated with alpha2.
    Outpus:
        log_ratio:      Float:      Natural log of ratio of likelihoods, used in acceptance.
    '''
    log_ratio = 0.5 * ((((alpha1 - mu_p) ** 2 - (alpha2 - mu_p) ** 2) / sigma_p ** 2) + (f1_norm ** 2 - f2_norm ** 2)/ sigma_l ** 2)
    
    return log_ratio

def A_mat(u):
    '''
    Format u.
    '''
    return u

def random_walk_metropolis(alpha0,
                           y, 
                           sigma_q, 
                           sigma_p,
                           sigma_l,
                           mu_p,
                           nx,
                           ny,
                           tau,
                           epsilon,
                           iterations,
                           num_steps,
                           dt_min,
                           dt_max,
                           reg
                           ):
    '''
    Carries out iterations of the random walk Metropolis-Hastings Algorithm using likelihood estimator.

    Inputs:
        alpha0:         Float:      Initial value for alpha.
        y:              np.Array:   Generated data encoding information about heat distribution in time.
        sigma_q:        Float:      Variance of proposal distribution (stepsize).
        sigma_p:        Float:      Variance of prior distribution. 
        sigma_l:        Float:      Variance used in likelihood caluclation (hyperparameter).
        mu_p:           Float:      Mean of prior distribution.
        nx:             Int:        Size of fine mesh (must be square, nx=ny).
        tau:            Float:      Rate of growth of hot wall boundary.
        epsilon:        Float:      Diffusion coefficient from advection-diffusion equation.
        iterations:     Int:        Desired number of iterations for delayed acceptance alogorithm.
        num_steps:      Int:        Number of steps in time calculated by the double-glazing solver.
        dt_min:         Float:      Initial timestepping value (variable time-stepping).
        dt_max:         Float:      Limit of dt (variable time-stepping)
        reg:            Float:      Regularisation constant used in variable time-stepping (hyperparameter)
    Outpus:
        alpha_list:     List:       List of samples for alpha generated by delayed acceptance algorithm.
    '''

    mesh = stretch_mesh(nx=nx, ny=ny)
    
    alpha_list = [alpha0]
    alpha1 = alpha0
    u1, __ = master_solver(mesh,
                           tau,
                           alpha1,
                           epsilon,
                           num_steps,
                           dt_min,
                           dt_max,
                           reg
                           )

    u1_norm = np.linalg.norm(y-A_mat(u1))

    for i in range(iterations):

        alpha2 = np.random.normal(alpha1, sigma_q)
        u2, __ = master_solver(mesh,
                               tau,
                               alpha2,
                               epsilon,
                               num_steps,
                               dt_min,
                               dt_max,
                               reg
                               )

        u2_norm = np.linalg.norm(y-A_mat(u2))

        A = log_ratio(#y,
                      #u1,
                      #u2,
                      alpha1,
                      alpha2,
                      sigma_p,
                      sigma_l,
                      mu_p,
                      u1_norm,
                      u2_norm
                      )

        if A >= 0 or np.log(np.random.uniform(0,1)) <= A:
            alpha1 = alpha2
            u1 = u2
            u1_norm = u2_norm

        alpha_list.append(alpha1)
        
        print(i)

    return alpha_list


if __name__ == "__main__":

    import pickle 

    def main():

        # Solver variables.
        alpha0 = 2
        tau = 1/10
        epsilon = 1/100
        num_steps = 60
        nx = 32
        ny = 32
        dt_min = 1e-3
        dt_max = 0.1
        reg = 10

        # MCMC vairables.
        iterations = 100
        sigma_q = 0.1
        sigma_p = 1
        mu_p = 0
        sigma_l = 0.2

        # Data augmentation.
        alpha_star = 4
        var_noise = 0.3

        with open('Master/Data_eps100_num150000_tau10_alpha0/master_data_32_interpolate', 'rb') as file:
            y_star = pickle.load(file)
        
        y_star_coarse = time_organiser(y_star,
                                       dt_min,
                                       dt_max,
                                       tau,
                                       reg,
                                       num_steps
                                       )[:-1] # Make removing last element more elegant!


        # mesh = stretch_mesh(nx=nx, ny=ny)

        # y_star_coarse, __ = master_solver(#nx,
        #                                   #ny,
        #                                   mesh,
        #                                   tau,
        #                                   alpha_star,
        #                                   epsilon,
        #                                   num_steps,
        #                                   dt_min,
        #                                   dt_max,
        #                                   reg
        #                                   )

        y = y_star_coarse + np.random.normal(0, var_noise, np.shape(y_star_coarse))

        #+ np.random.normal(np.zeros(np.shape(y_star)), var_noise)

        alpha_list = random_walk_metropolis(alpha0,
                                            y, 
                                            sigma_q, 
                                            sigma_p,
                                            sigma_l,
                                            mu_p,
                                            nx,
                                            ny,
                                            tau,
                                            epsilon,
                                            iterations,
                                            num_steps,
                                            dt_min,
                                            dt_max,
                                            reg
                                            )

        return alpha_list
    
    alpha_list = main()

    print(alpha_list)
